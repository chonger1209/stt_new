# 时间流像素格日志优化说明

## 问题描述
用户反馈程序每100ms都在绘制时间流像素格，导致日志文件快速增长，包含大量重复的像素格绘制日志。

## 问题分析
1. `render_stats_chart`方法在每次刷新屏幕时间统计时都会调用`render_history_stream`
2. `render_history_stream`方法会对每个像素格都输出一条日志，即使是重复绘制的像素格
3. 屏幕时间刷新频率设置为10次/10秒，导致每秒都会重绘整个时间流

## 解决方案
实现了只记录新增像素格的日志优化：

1. **添加像素格记录机制**：
   - 在`ScreenTimeTracker`类中添加`drawn_pixels`集合，记录已绘制的像素格
   - 使用`(应用名, x坐标, y坐标)`作为像素格的唯一标识

2. **优化日志输出**：
   - 在绘制像素格前检查是否为新增像素格
   - 只对新增像素格输出详细的绘制日志
   - 在渲染完成日志中添加新增像素格数量统计

3. **清理机制**：
   - 在清空画布时同时清空`drawn_pixels`集合
   - 确保在需要重新渲染时能正确记录新增像素格

## 代码修改
修改了`stt_new.py`文件中的`render_history_stream`方法：

1. 添加像素格记录初始化：
```python
# 初始化已绘制像素格记录（用于优化日志）
if not hasattr(self, 'drawn_pixels'):
    self.drawn_pixels = set()

# 记录新增像素格数量
new_pixels_count = 0
```

2. 优化像素格绘制日志：
```python
# 创建像素格的唯一标识
pixel_key = (app, x, y)

# 只对新增像素格记录日志
is_new_pixel = pixel_key not in self.drawn_pixels
if is_new_pixel:
    new_pixels_count += 1
    self.logger.info(f"绘制时间流像素格 - 应用: {app}, 位置: ({x}, {y}), 颜色: {color}, 持续时间: {dur:.2f}秒")
    self.drawn_pixels.add(pixel_key)
```

3. 添加清理机制：
```python
# 清空已绘制像素格记录
if hasattr(self, 'drawn_pixels'):
    self.drawn_pixels.clear()
```

4. 更新完成日志：
```python
self.logger.info(f"时间流渲染完成 - 总应用数: {len(valid_history)}, 总像素格数: {total_blocks}, 新增像素格数: {new_pixels_count}, 画布宽度: {w}px, 画布高度: {self.history_bar_h}px")
```

## 优化效果
1. **减少日志量**：只记录新增像素格的日志，大幅减少日志文件大小
2. **提高性能**：减少不必要的日志输出，降低I/O开销
3. **保持信息价值**：仍然记录新增像素格的详细信息，便于调试
4. **统计信息**：提供新增像素格数量统计，便于了解渲染情况

## 测试方法
1. 运行`test_log_optimization.py`脚本测试优化效果
2. 检查日志文件中是否包含"新增像素格数"的统计信息
3. 对比优化前后的日志文件大小

## 注意事项
1. 该优化不影响程序的任何功能，只影响日志输出
2. 在清空画布时会重置像素格记录，确保下次渲染时能正确记录新增像素格
3. 优化后的日志仍然包含足够的信息用于调试和监控